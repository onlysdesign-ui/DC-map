<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bank Screen Demo</title>
  <style>
    :root {
      --screen-width: 393px;
      --screen-height: 852px;
      --text-dark: #111111;
      --text-muted: #6f6f6f;
      --green-dark: #0b5d3b;
      --green-light: #34d399;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ffffff;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      color: var(--text-dark);
    }

    .phone-shell {
      width: var(--screen-width);
      height: var(--screen-height);
      background: #ffffff;
      border-radius: 28px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.18);
    }

    canvas#physics {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .ui-layer {
      position: absolute;
      inset: 0;
      z-index: 3;
      display: flex;
      flex-direction: column;
      padding: 28px 24px 30px;
      pointer-events: none;
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 40px;
    }

    .icon-btn {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
    }

    .icon-btn svg {
      width: 20px;
      height: 20px;
      stroke: #5f6368;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      display: block;
    }

    .content-block {
      margin-top: 170px;
      text-align: center;
    }

    .content-block .label {
      font-size: 15px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .content-block .amount {
      font-size: 40px;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .content-block .profit {
      font-size: 16px;
      color: var(--green-light);
    }

    .projection-block {
      margin-top: 34px;
      text-align: center;
      color: #1a1a1a;
      opacity: 0.5;
      line-height: 1.35;
    }

    .projection-block .projection-label {
      font-size: 14px;
      margin-bottom: 6px;
    }

    .projection-block .projection-value {
      font-size: 24px;
      font-weight: 500;
    }

    .bottom-action {
      margin-top: auto;
      display: flex;
      justify-content: center;
    }

    .bottom-action button {
      pointer-events: auto;
      border: none;
      background: #111;
      color: #fff;
      font-size: 16px;
      padding: 14px 44px;
      border-radius: 22px;
      font-weight: 500;
    }

    .level-line {
      position: absolute;
      left: 16px;
      right: 16px;
      height: 1px;
      background: rgba(11, 93, 59, 0.25);
      z-index: 2;
      border-radius: 999px;
      pointer-events: none;
      top: 78px;
    }
  </style>
</head>
<body>
  <div class="phone-shell" id="phone">
    <canvas id="physics" width="393" height="852"></canvas>
    <div class="level-line" id="levelLine"></div>
    <div class="ui-layer">
      <div class="top-bar" id="topBar">
        <div class="icon-btn" aria-label="Назад">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M15 5l-7 7 7 7" />
          </svg>
        </div>
        <div class="icon-btn" aria-label="Настройки">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z" />
            <path d="M19.4 15a7.6 7.6 0 0 0 .1-1 7.6 7.6 0 0 0-.1-1l2-1.5-2-3.5-2.3.7a7.2 7.2 0 0 0-1.7-1l-.4-2.4h-4l-.4 2.4a7.2 7.2 0 0 0-1.7 1l-2.3-.7-2 3.5 2 1.5a7.6 7.6 0 0 0-.1 1 7.6 7.6 0 0 0 .1 1l-2 1.5 2 3.5 2.3-.7a7.2 7.2 0 0 0 1.7 1l.4 2.4h4l.4-2.4a7.2 7.2 0 0 0 1.7-1l2.3.7 2-3.5-2-1.5z" />
          </svg>
        </div>
      </div>

      <div class="content-block" id="contentBlock">
        <div class="label">На счету сейчас</div>
        <div class="amount">1 277 200 ₽</div>
        <div class="profit">+277 200 ₽ прибыли</div>
      </div>

      <div class="projection-block">
        <div class="projection-label">Через 2 года и 3 месяца</div>
        <div class="projection-value">1 720 000 ₽</div>
      </div>

      <div class="bottom-action" id="bottomAction">
        <button type="button">Хорошо.</button>
      </div>
    </div>
  </div>

  <script>
    const SCREEN_WIDTH = 393;
    const SCREEN_HEIGHT = 852;
    const MAX_PARTICLES = 1200;
    const CELL_SIZE = 12;
    const COLLISION_ITERATIONS = 5;

    const colors = {
      dark: "rgba(11, 93, 59, 0.9)",
      light: "rgba(52, 211, 153, 0.82)",
    };

    const state = {
      canvas: null,
      ctx: null,
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
      particles: [],
      grid: new Map(),
      colliders: [],
      lastTime: 0,
      elapsed: 0,
      levelY: SCREEN_HEIGHT - 120,
      tilt: { x: 0, y: 0 },
      spawn: {
        darkAccumulator: 0,
        lightAccumulator: 0,
      },
    };

    function setupCanvas() {
      const canvas = document.getElementById("physics");
      const dpr = window.devicePixelRatio || 1;
      canvas.width = SCREEN_WIDTH * dpr;
      canvas.height = SCREEN_HEIGHT * dpr;
      canvas.style.width = `${SCREEN_WIDTH}px`;
      canvas.style.height = `${SCREEN_HEIGHT}px`;
      const ctx = canvas.getContext("2d");
      ctx.scale(dpr, dpr);
      state.canvas = canvas;
      state.ctx = ctx;
      state.width = SCREEN_WIDTH;
      state.height = SCREEN_HEIGHT;
    }

    function setupUI() {
      const phone = document.getElementById("phone");
      phone.style.width = `${SCREEN_WIDTH}px`;
      phone.style.height = `${SCREEN_HEIGHT}px`;
    }

    function initColliders() {
      const phoneRect = document.getElementById("phone").getBoundingClientRect();
      const topRect = document.getElementById("topBar").getBoundingClientRect();
      const contentRect = document.getElementById("contentBlock").getBoundingClientRect();
      const buttonRect = document.getElementById("bottomAction").getBoundingClientRect();

      const toLocal = (rect) => ({
        x: rect.left - phoneRect.left,
        y: rect.top - phoneRect.top,
        w: rect.width,
        h: rect.height,
      });

      state.colliders = [
        toLocal(topRect),
        toLocal(contentRect),
        toLocal(buttonRect),
      ];
    }

    function spawnDark(dt) {
      const rate = state.elapsed < 1.2 ? 80 + Math.random() * 60 : 20 + Math.random() * 25;
      state.spawn.darkAccumulator += rate * dt;
      const count = Math.floor(state.spawn.darkAccumulator);
      if (count <= 0) {
        return;
      }
      state.spawn.darkAccumulator -= count;
      for (let i = 0; i < count; i++) {
        addParticle("dark");
      }
    }

    function spawnLight(dt, allow) {
      if (!allow) {
        return;
      }
      const rate = 8 + Math.random() * 12;
      state.spawn.lightAccumulator += rate * dt;
      const count = Math.floor(state.spawn.lightAccumulator);
      if (count <= 0) {
        return;
      }
      state.spawn.lightAccumulator -= count;
      for (let i = 0; i < count; i++) {
        addParticle("light");
      }
    }

    function addParticle(type) {
      if (state.particles.length >= MAX_PARTICLES) {
        trimParticles();
      }
      const radius = 2 + Math.random() * 2;
      const x = 22 + Math.random() * (state.width - 44);
      let y = state.height - 8 - Math.random() * 18;
      let vy = -1.5 - Math.random() * 1.5;
      let vx = (Math.random() - 0.5) * 0.6;

      if (type === "light") {
        y = state.height * 0.8 + Math.random() * 12;
        vy = -2.2 - Math.random() * 2.4;
        vx = (Math.random() - 0.5) * 0.9;
      }

      const particle = {
        type,
        x,
        y,
        px: x - vx,
        py: y - vy,
        radius,
        invMass: type === "dark" ? 0.2 : 1,
        damping: type === "dark" ? 0.98 : 0.985,
        color: type === "dark" ? colors.dark : colors.light,
        age: 0,
        resting: 0,
      };

      state.particles.push(particle);
    }

    function trimParticles() {
      const velocityMag = (p) => Math.abs(p.x - p.px) + Math.abs(p.y - p.py);
      state.particles.sort((a, b) => {
        const av = velocityMag(a);
        const bv = velocityMag(b);
        if (av === bv) {
          return b.y - a.y;
        }
        return av - bv;
      });
      const removeCount = Math.max(1, state.particles.length - MAX_PARTICLES + 10);
      state.particles.splice(0, removeCount);
    }

    function stepVerlet(dt) {
      const axBase = state.tilt.x * 120;
      const ayBase = 30 + state.tilt.y * 40;
      const dtSq = dt * dt;

      state.particles.forEach((p) => {
        const vx = (p.x - p.px) * p.damping;
        const vy = (p.y - p.py) * p.damping;
        p.px = p.x;
        p.py = p.y;
        p.x += vx + axBase * dtSq;
        p.y += vy + ayBase * dtSq;
        p.age += dt;
      });
    }

    function buildGrid() {
      state.grid.clear();
      state.particles.forEach((p, index) => {
        const cx = Math.floor(p.x / CELL_SIZE);
        const cy = Math.floor(p.y / CELL_SIZE);
        const key = `${cx},${cy}`;
        if (!state.grid.has(key)) {
          state.grid.set(key, []);
        }
        state.grid.get(key).push(index);
      });
    }

    function solveParticleCollisions(iterations) {
      for (let iter = 0; iter < iterations; iter++) {
        buildGrid();
        state.particles.forEach((p, index) => {
          const cx = Math.floor(p.x / CELL_SIZE);
          const cy = Math.floor(p.y / CELL_SIZE);
          for (let gx = cx - 1; gx <= cx + 1; gx++) {
            for (let gy = cy - 1; gy <= cy + 1; gy++) {
              const key = `${gx},${gy}`;
              const cell = state.grid.get(key);
              if (!cell) {
                continue;
              }
              cell.forEach((otherIndex) => {
                if (otherIndex <= index) {
                  return;
                }
                const other = state.particles[otherIndex];
                const dx = other.x - p.x;
                const dy = other.y - p.y;
                const distSq = dx * dx + dy * dy;
                const minDist = p.radius + other.radius;
                if (distSq < minDist * minDist) {
                  const dist = Math.sqrt(distSq) || 0.0001;
                  const overlap = minDist - dist;
                  const nx = dx / dist;
                  const ny = dy / dist;
                  const totalInv = p.invMass + other.invMass;
                  const corrA = (overlap * (p.invMass / totalInv)) * -1;
                  const corrB = overlap * (other.invMass / totalInv);
                  p.x += nx * corrA;
                  p.y += ny * corrA;
                  other.x += nx * corrB;
                  other.y += ny * corrB;
                }
              });
            }
          }
        });
      }
    }

    function resolveBoundary(p) {
      const friction = 0.15;
      let collided = false;
      if (p.x - p.radius < 0) {
        p.x = p.radius;
        collided = true;
      } else if (p.x + p.radius > state.width) {
        p.x = state.width - p.radius;
        collided = true;
      }
      if (p.y - p.radius < 0) {
        p.y = p.radius;
        collided = true;
      } else if (p.y + p.radius > state.height) {
        p.y = state.height - p.radius;
        collided = true;
      }
      if (collided) {
        const vx = p.x - p.px;
        const vy = p.y - p.py;
        p.px = p.x - vx * (1 - friction);
        p.py = p.y - vy * (1 - friction);
      }
    }

    function resolveCollider(p, rect) {
      const friction = 0.2;
      const expanded = {
        x: rect.x - p.radius,
        y: rect.y - p.radius,
        w: rect.w + p.radius * 2,
        h: rect.h + p.radius * 2,
      };
      if (
        p.x >= expanded.x &&
        p.x <= expanded.x + expanded.w &&
        p.y >= expanded.y &&
        p.y <= expanded.y + expanded.h
      ) {
        const left = Math.abs(p.x - expanded.x);
        const right = Math.abs(expanded.x + expanded.w - p.x);
        const top = Math.abs(p.y - expanded.y);
        const bottom = Math.abs(expanded.y + expanded.h - p.y);
        const min = Math.min(left, right, top, bottom);
        if (min === left) {
          p.x = expanded.x;
        } else if (min === right) {
          p.x = expanded.x + expanded.w;
        } else if (min === top) {
          p.y = expanded.y;
        } else {
          p.y = expanded.y + expanded.h;
        }
        const vx = p.x - p.px;
        const vy = p.y - p.py;
        p.px = p.x - vx * (1 - friction);
        p.py = p.y - vy * (1 - friction);
      }
    }

    function solveColliders() {
      state.particles.forEach((p) => {
        resolveBoundary(p);
        state.colliders.forEach((rect) => resolveCollider(p, rect));
      });
    }

    function computeLevel() {
      const darks = state.particles.filter((p) => p.type === "dark");
      if (darks.length === 0) {
        return state.height - 120;
      }
      const sorted = darks.map((p) => p.y).sort((a, b) => a - b);
      const count = Math.max(1, Math.floor(sorted.length * 0.1));
      const avg = sorted.slice(0, count).reduce((sum, v) => sum + v, 0) / count;
      return avg;
    }

    function draw() {
      const ctx = state.ctx;
      ctx.clearRect(0, 0, state.width, state.height);
      state.particles.forEach((p) => {
        ctx.beginPath();
        ctx.fillStyle = p.color;
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      const line = document.getElementById("levelLine");
      line.style.top = `${state.levelY.toFixed(1)}px`;
    }

    function setupTilt() {
      const updateTilt = (x, y) => {
        state.tilt.x = Math.max(-1, Math.min(1, x));
        state.tilt.y = Math.max(-1, Math.min(1, y));
      };

      if (window.DeviceOrientationEvent) {
        window.addEventListener("deviceorientation", (event) => {
          const gamma = event.gamma ?? 0;
          const beta = event.beta ?? 0;
          updateTilt(gamma / 30, beta / 45);
        });
      }

      window.addEventListener("mousemove", (event) => {
        const rect = document.getElementById("phone").getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = (event.clientX - cx) / (rect.width / 2);
        const dy = (event.clientY - cy) / (rect.height / 2);
        updateTilt(dx * 0.5, dy * 0.4);
      });
    }

    function loop(timestamp) {
      if (!state.lastTime) {
        state.lastTime = timestamp;
      }
      const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
      state.lastTime = timestamp;
      state.elapsed += dt;

      const levelTarget = computeLevel();
      state.levelY += (levelTarget - state.levelY) * 0.08;

      spawnDark(dt);
      const allowLight = state.levelY < state.height * 0.75;
      spawnLight(dt, allowLight);

      stepVerlet(dt);
      solveParticleCollisions(COLLISION_ITERATIONS);
      solveColliders();
      draw();

      requestAnimationFrame(loop);
    }

    setupCanvas();
    setupUI();
    initColliders();
    setupTilt();
    window.addEventListener("resize", () => {
      setupCanvas();
      initColliders();
    });
    requestAnimationFrame(loop);
  </script>
</body>
</html>
