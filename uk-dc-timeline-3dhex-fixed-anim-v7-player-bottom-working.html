<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>UK DC timeline (MapLibre + deck.gl + H3)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- deck.gl -->
  <script src="https://unpkg.com/deck.gl@8.9.36/dist.min.js"></script>

  <!-- H3 (stable hex indexing) -->
  <script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>
<script src="https://unpkg.com/d3-ease@3"></script>
    
  <style>
    :root {
      color-scheme: dark;
      --ui-bg: rgba(10, 15, 26, 0.92);
      --ui-border: rgba(148, 163, 184, 0.18);
      --ui-text: #e2e8f0;
      --ui-muted: #94a3b8;
      --ui-pill: rgba(148, 163, 184, 0.12);
      --ui-button: rgba(15, 23, 42, 0.9);
      --ui-button-hover: rgba(30, 41, 59, 0.9);
      --ui-accent: #60a5fa;
    }
    html, body { margin:0; height:100%; background:#0b1220; color:var(--ui-text); font:14px system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #container { position:relative; height:100%; }
    #map { position:absolute; inset:0; }

    .panel {
      position:absolute; z-index:1000; left:16px; top:16px;
      background: var(--ui-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 12px 14px;
      border: 1px solid var(--ui-border);
      border-radius: 14px;
      box-shadow: 0 14px 40px rgba(2, 6, 23, 0.6);
      max-width: 480px;
    }
    .panel--collapsed { padding: 10px; max-width: 220px; }
    .panel--collapsed .panel-body { display: none; }
    .panel--collapsed .title h1,
    .panel--collapsed #shownPill { display: none; }
    .title { display:flex; align-items:center; justify-content: space-between; gap: 12px; }
    .title h1 { font-size: 14px; margin: 0; font-weight: 650; color: var(--ui-text); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(30, 41, 59, 0.95);
      padding:7px 12px; border-radius:10px;
      cursor:pointer; user-select:none; color: var(--ui-text);
    }
    .btn:hover { background: var(--ui-button-hover); }
    .btn:focus-visible { outline: 2px solid var(--ui-accent); outline-offset: 2px; }
    input[type="text"]{
      border:1px solid rgba(148, 163, 184, 0.35);
      padding:7px 10px; border-radius:10px;
      width:220px; outline:none;
      background: rgba(15, 23, 42, 0.9);
      color: var(--ui-text);
    }
    input[type="file"]{
      border:1px solid rgba(148, 163, 184, 0.35);
      padding:6px 10px;
      border-radius:10px;
      background: rgba(15, 23, 42, 0.9);
      color: var(--ui-text);
    }
    input[type="file"]::file-selector-button{
      margin-right:10px;
      border:1px solid rgba(148, 163, 184, 0.4);
      background: rgba(30, 41, 59, 0.95);
      color: var(--ui-text);
      padding:6px 10px;
      border-radius:8px;
      cursor:pointer;
    }
    input[type="range"]{ width:100%; }
    .pill{
      display:inline-block; padding:3px 10px;
      border:none;
      border-radius:999px; background:var(--ui-pill);
      font-size:12px; color:var(--ui-text); white-space:nowrap;
    }
    .labelText{
      font-size:12px;
      color: var(--ui-muted);
      font-weight: 500;
    }
    .dot{ width:10px; height:10px; border-radius:999px;
      background: rgb(96,165,250);
      box-shadow:0 0 0 6px rgba(96,165,250,0.2);
      display:inline-block; margin-right:8px;
    }
    .timeline { margin-top:10px; padding-top:10px; border-top:1px solid var(--ui-border); display:grid; gap:10px; }
    .timeinfo{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--ui-text); }
    .twoCols{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .labelRow{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .muted{ color:var(--ui-muted); font-size:12px; margin-top:8px; }
    .stat{ margin-top:10px; font-size:12px; color:var(--ui-text); }
    .select {
      border:1px solid var(--ui-border);
      background: rgba(15, 23, 42, 0.8);
      padding:7px 10px;
      border-radius:10px;
      color:var(--ui-text);
      outline:none;
    }
  
    /* Infographic feel: лёгкое свечение/смягчение именно для deck.gl слоя */
    canvas.deckgl-overlay, .deckgl-overlay canvas {
      filter:
        drop-shadow(0 0 6px rgba(0, 125, 255, 0.22))
        drop-shadow(0 0 18px rgba(0, 125, 255, 0.10));
    }


    /* Player dock */
    .playerDock{
      position:absolute;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      z-index:1200;
      pointer-events:none; /* allow map interactions around it */
      width:min(720px, calc(100vw - 40px));
    }
    .playerCard{
      pointer-events:auto;
      background: var(--ui-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--ui-border);
      border-radius: 16px;
      box-shadow: 0 14px 40px rgba(2, 6, 23, 0.7);
      padding: 10px 12px;
    }
    .playerMeta{
      display:flex;
      flex-direction:column;
      gap:4px;
      margin-bottom:12px;
      pointer-events:auto;
    }
    .playerControls{ display:grid; grid-template-columns:auto 1fr; gap:10px; align-items:center; margin-top:8px; }
    .playerSlider{ width:100%; margin:0; }
    .playerLabels{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--ui-text); }
    .pillGhost{ opacity:0.8; }
    .pillBig{ font-size:12px; padding:4px 12px; }
    .btnIcon{ width:38px; height:38px; border-radius:12px; padding:0; display:grid; place-items:center; }
    .btnPlayIcon{ width:46px; height:46px; border-radius:14px; padding:0; display:grid; place-items:center; font-size:16px; }
    .current-date {
      font-size: 18px;
      font-weight: 500;
      display: flex;
      align-items: baseline;
      gap: 8px;
      letter-spacing: 0.02em;
      color: var(--ui-text);
      background: none;
      border: none;
      box-shadow: none;
      padding: 0;
      border-radius: 0;
      line-height: 1.2;
    }
    .current-subtitle{
      font-size: 18px;
      font-weight: 500;
      color: var(--ui-text);
      opacity: 0.9;
    }
    .current-year{
      font-size: 3em;
      line-height: 1;
      font-weight: 600;
    }
    .current-month{
      font-size: 1em;
      line-height: 1.2;
    }
</style>
</head>

<body>
<div id="container">
  <div id="map"></div>

  <div class="panel" id="controlPanel">
    <div class="title">
      <h1><span class="dot"></span>Data centers timeline (3D hex)</h1>
      <button id="togglePanel" class="btn btnIcon" type="button" aria-label="Collapse panel" title="Collapse panel">⟨</button>
      <span id="shownPill" class="pill">0 shown</span>
    </div>

    <div class="panel-body">
    <div class="row" style="margin-top:10px;">
      <input id="file" type="file" accept=".geojson,.json" class="btn">
      <button id="clear" class="btn" type="button">Clear</button>
      <button id="fit" class="btn" type="button">Fit</button>
    </div>
    <div class="row" style="margin-top:8px;">
      <button class="btn server-file" type="button" data-file="DC-UK.geojson">Load DC-UK (server)</button>
      <button class="btn server-file" type="button" data-file="DC-global.geojson">Load DC-global (server)</button>
    </div>
<div class="settings">
      <div class="twoCols">
        <div>
          <div class="labelRow">
            <span class="labelText">H3 resolution</span>
            <span id="resVal" class="pill">6</span>
          </div>
          <select id="h3res" class="select">
            <option value="5">5 (coarse)</option>
            <option value="6" selected>6 (default)</option>
            <option value="7">7 (detailed)</option>
            <option value="8">8 (very detailed)</option>
          </select>
        </div>

        <div>
          <div class="labelRow">
            <span class="labelText">Elevation</span>
            <span id="elevVal" class="pill">x240</span>
          </div>
          <input id="elev" type="range" min="40" max="12000" step="20" value="8000">
        </div>
      </div>
      <div style="margin-top:10px;">
        <div class="labelRow">
          <span class="labelText">Palette</span>
          <span id="paletteVal" class="pill">Mono Blue</span>
        </div>
        <select id="palette" class="select" style="width:100%;">
          <optgroup label="Gradient bottom-up (fixed)">
            <option value="gradSunrise">Gradient Sunrise</option>
            <option value="gradEmerald">Gradient Emerald</option>
            <option value="gradMagenta">Gradient Magenta</option>
            <option value="gradCitrus">Gradient Citrus</option>
            <option value="gradRuby">Gradient Ruby</option>
            <option value="gradSky">Gradient Cyan</option>
            <option value="gradBlue">Gradient Blue</option>
          </optgroup>
          <optgroup label="Mono (contrast for dark map)">
            <option value="solidAmber">Mono Amber</option>
            <option value="solidCoral">Mono Coral</option>
            <option value="solidMint">Mono Mint</option>
            <option value="solidViolet">Mono Violet</option>
            <option value="solidLime">Mono Lime</option>
            <option value="solidSky">Mono Cyan</option>
            <option value="solidBlue" selected>Mono Blue</option>
          </optgroup>
          <optgroup label="Height-dependent gradients">
            <option value="heightHeat">Height Heat</option>
            <option value="heightAurora">Height Aurora</option>
            <option value="heightPlasma">Height Plasma</option>
            <option value="heightCopper">Height Copper</option>
            <option value="heightIcefire">Height Icefire</option>
            <option value="heightSky">Height Cyan</option>
            <option value="heightBlue">Height Blue</option>
          </optgroup>
        </select>
      </div>

      <div class="row" style="justify-content: space-between; margin-top:10px;">
        <span class="labelText">Distribution</span>
        <label class="labelText" style="display:flex; align-items:center; gap:8px; cursor:pointer;">
          <input id="logToggle" type="checkbox">
          log(1 + count)
        </label>
      </div>
    </div>
  </div>
</div>
    <div id="stat" class="stat" style="display:none"></div>

  </div>

  <!-- Center-bottom player dock -->
  <div class="playerDock" aria-label="Timeline player">
    <div class="playerMeta">
      <span id="timeLabel" class="current-date">—</span>
      <span class="current-subtitle">Data Center Expansion Map</span>
    </div>
    <div class="playerCard">
      <div class="playerControls">
        <button id="play" class="btn btnPlayIcon" type="button" aria-label="Play/Pause" title="Play/Pause">▶</button>
        <input id="slider" class="playerSlider" type="range" min="0" max="0" value="0" step="1" disabled />
      </div>

      <div class="playerLabels">
        <span id="startLabel" class="pill pillGhost">—</span>
        <span id="stepsLabel" class="pill pillGhost">0 steps</span>
        <span id="endLabel" class="pill pillGhost">—</span>
      </div>
    </div>
  </div>
</div>

<script>
  const {MapboxOverlay, PolygonLayer} = deck;
  const h3 = window.h3 || window.h3js;
    if (!h3) {
      throw new Error("h3-js не загрузился (нет window.h3 / window.h3js)");
    }

  // Basemap style
const STYLE_URL = "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json";

  const map = new maplibregl.Map({
    container: "map",
    style: STYLE_URL,
    center: [-3.0, 54.5],
    zoom: 5.8,
    pitch: 68,
    bearing: -12,
    antialias: true
  });
  map.addControl(new maplibregl.NavigationControl({showCompass: true}), "top-right");

  // UI
  const statEl = document.getElementById("stat");
  const fileEl = document.getElementById("file");
const sliderEl = document.getElementById("slider");
  const timeLabelEl = document.getElementById("timeLabel");
  const stepsLabelEl = document.getElementById("stepsLabel");
  const shownPillEl = document.getElementById("shownPill");
  const playBtn = document.getElementById("play");
  const elevEl = document.getElementById("elev");
  const elevValEl = document.getElementById("elevVal");
  const logToggleEl = document.getElementById("logToggle");
  const h3resEl = document.getElementById("h3res");
  const resValEl = document.getElementById("resVal");
  const paletteEl = document.getElementById("palette");
  const paletteValEl = document.getElementById("paletteVal");
  const panelEl = document.getElementById("controlPanel");
  const togglePanelEl = document.getElementById("togglePanel");

  function setStat(t){ if (statEl) statEl.textContent = t || ""; }
  function setVals(){
    elevValEl.textContent = `x${Number(elevEl.value)}`;
    resValEl.textContent = String(h3resEl.value);
    if (paletteValEl) {
      const selected = paletteEl?.selectedOptions?.[0];
      paletteValEl.textContent = selected ? selected.textContent.replace(" (dark map)", "") : "—";
    }
  }
  setVals();

  // Data:
  // point: {coordinates:[lon,lat], properties, tMonthMs}
  let allPoints = [];
  let filteredPoints = [];

  // timeline months (UTC month start)
  let months = [];
  let monthIndexByMs = new Map();

  // accumulative counts per month: Array<Map<h3Cell, count>>
  let h3ByMonth = [];

  // layer data for current frame: [{cell, count}]
  let cellsNow = [];
  // Stable registry: cell -> object reused across frames
    const cellRegistry = new Map(); // cell -> {cell, count}
    let stableCells = [];           // stable array passed to deck.gl
  

  // Base grid (so 0-count hexes still render)
  const UK_GEOJSON_URL = "https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson";
  let ukFeature = null;                 // GeoJSON feature for UK
  const baseGridByRes = new Map();      // res -> array of h3 cell ids
  let buildToken = 0;

  async function ensureUKFeature() {
    if (ukFeature) return ukFeature;
    const r = await fetch(UK_GEOJSON_URL);
    if (!r.ok) throw new Error("Failed to fetch UK GeoJSON: " + r.status);
    const gj = await r.json();
    const f = gj.features.find(ft => {
      const nm = (ft.properties?.ADMIN || ft.properties?.name || "").toLowerCase();
      return nm === "united kingdom";
    });
    if (!f) throw new Error("UK feature not found in countries.geojson");
    ukFeature = f;
    return ukFeature;
  }
                  
  function seedRegistryFromPoints(points, res) {
  for (const p of points) {
    const [lon, lat] = p.coordinates || [];
    if (typeof lon !== "number" || typeof lat !== "number") continue;

    const cell = h3.latLngToCell(lat, lon, res);
    if (!cellRegistry.has(cell)) cellRegistry.set(cell, { cell, count: 0 });
  }
  stableCells = Array.from(cellRegistry.values());
}

  function swapLonLatToLatLon(geom) {
    // GeoJSON uses [lon,lat]; h3-js expects [lat,lon]
    if (geom.type === "Polygon") {
      return { type: "Polygon", coordinates: geom.coordinates.map(ring => ring.map(([lon, lat]) => [lat, lon])) };
    }
    if (geom.type === "MultiPolygon") {
      return { type: "MultiPolygon", coordinates: geom.coordinates.map(poly => poly.map(ring => ring.map(([lon, lat]) => [lat, lon]))) };
    }
    throw new Error("Unsupported geometry type: " + geom.type);
  }

  async function ensureBaseGrid(res) {
    if (baseGridByRes.has(res)) return baseGridByRes.get(res);
    const uk = await ensureUKFeature();
    const swapped = swapLonLatToLatLon(uk.geometry);
    const cells = h3.polygonToCells(swapped, res);
    baseGridByRes.set(res, cells);

    // register all cells as stable objects with count=0
    for (const cell of cells) {
      if (!cellRegistry.has(cell)) cellRegistry.set(cell, { cell, count: 0 });
    }
    stableCells = Array.from(cellRegistry.values());
    return cells;
  }

  // playback
  let playing = false;
  let timer = null;
  const PLAY_INTERVAL_MS = 150;
  let frameTick = 0; // increments each frame to force attribute updates & transitions
  let glowTicker = null;
  let glowActiveUntil = 0;
  let lastGlowUpdate = 0;
  const GLOW_DURATION_MS = 1200;
  const GLOW_DELAY_MS = 140;
  const GLOW_UPDATE_INTERVAL_MS = 70;

  // Helpers
  function getProp(p, keys) { for (const k of keys) if (p && p[k] != null && p[k] !== "") return p[k]; return ""; }
  function parseTimestampToMs(ts) { const d = new Date(ts); const ms = d.getTime(); return Number.isFinite(ms) ? ms : null; }
  function toMonthMs(ms) { const d = new Date(ms); return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1); }
  function buildMonthRange(minMs, maxMs) {
    if (minMs == null || maxMs == null) return [];
    const start = new Date(minMs);
    const end = new Date(maxMs);
    let cursor = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), 1));
    const endMonth = new Date(Date.UTC(end.getUTCFullYear(), end.getUTCMonth(), 1));
    const range = [];
    while (cursor <= endMonth) {
      range.push(cursor.getTime());
      cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth() + 1, 1));
    }
    return range;
  }
  function fmtDay(ms) {
    const d = new Date(ms);
    const y = d.getUTCFullYear();
    const monthName = new Intl.DateTimeFormat("en-En", { month: "long" }).format(d);
    return { year: y, month: monthName };
  }
  function formatDayText(ms) {
    const { year, month } = fmtDay(ms);
    return `${year} ${month}`;
  }
  function renderTimeLabel(ms) {
    const { year, month } = fmtDay(ms);
    timeLabelEl.innerHTML = `<span class="current-year">${year}</span><span class="current-month">${month}</span>`;
  }
  function extractPointsFromGeoJSON(geo) {
    const pts = [];
    const feats = geo?.type === "FeatureCollection" ? (geo.features || []) :
                  geo?.type === "Feature" ? [geo] : [];
    for (const f of feats) {
      const g = f.geometry;
      if (!g) continue;
      if (g.type === "Point" && Array.isArray(g.coordinates)) {
        pts.push({ coordinates: g.coordinates, properties: f.properties || {} });
      }
    }
    return pts;
  }
  function boundsFromPoints(points) {
    let minLon = 180, minLat = 90, maxLon = -180, maxLat = -90, ok = false;
    for (const p of points) {
      const [lon, lat] = p.coordinates || [];
      if (typeof lon !== "number" || typeof lat !== "number") continue;
      ok = true;
      minLon = Math.min(minLon, lon); maxLon = Math.max(maxLon, lon);
      minLat = Math.min(minLat, lat); maxLat = Math.max(maxLat, lat);
    }
    return ok ? [minLon, minLat, maxLon, maxLat] : null;
  }
    
    function bboxToLatLonPolygon(b, padDeg = 0.6) {
  const [minLon, minLat, maxLon, maxLat] = b;
  const a = minLon - padDeg, btm = minLat - padDeg;
  const c = maxLon + padDeg, top = maxLat + padDeg;

  // h3-js polygonToCells ждёт [lat, lon]
  return {
    type: "Polygon",
    coordinates: [[
      [btm, a],
      [btm, c],
      [top, c],
      [top, a],
      [btm, a]
    ]]
  };
}

async function ensureBaseGridFromPoints(res) {
  const b = boundsFromPoints(filteredPoints.length ? filteredPoints : allPoints);
  if (!b) return [];

  const poly = bboxToLatLonPolygon(b, 0.8); // pad можно увеличить
  const cells = h3.polygonToCells(poly, res);

  // регистрируем все клетки в реестре как стабильные объекты count=0
  for (const cell of cells) {
    if (!cellRegistry.has(cell)) cellRegistry.set(cell, { cell, count: 0 });
  }
  stableCells = Array.from(cellRegistry.values());
  return cells;
}


  // Overlay
  const overlay = new MapboxOverlay({layers: []});
  map.addControl(overlay);

function makeLayer() {
  const elevationScale = Number(elevEl.value); // высота за 1 DC
  const useLog = !!logToggleEl.checked;
  const transform = (n) => useLog ? Math.log1p(n) : n;
    
    const BASE_ELEV = 0.18; // минимальная высота (до умножения на elevationScale)
    const FILL_ALPHA = 255; // полностью непрозрачные бары
    const LINE_ALPHA = 90;  // контур чуть мягче
    const LINE_WIDTH = 1.3; // px
    const palettes = {
      gradSunrise: {
        label: "Gradient Sunrise",
        range: [
          [40, 8, 20],
          [110, 20, 40],
          [180, 40, 70],
          [230, 90, 60],
          [255, 140, 60],
          [255, 185, 90],
          [255, 225, 140]
        ],
        gradient: true,
        fixedT: 0.85,
        glow: [255, 210, 160],
        edge: [80, 20, 30]
      },
      gradEmerald: {
        label: "Gradient Emerald",
        range: [
          [6, 35, 24],
          [12, 70, 44],
          [18, 105, 70],
          [24, 140, 96],
          [40, 175, 120],
          [70, 210, 150],
          [120, 235, 185]
        ],
        gradient: true,
        fixedT: 0.8,
        glow: [160, 255, 210],
        edge: [10, 50, 36]
      },
      gradMagenta: {
        label: "Gradient Magenta",
        range: [
          [35, 8, 50],
          [70, 20, 85],
          [110, 30, 120],
          [150, 40, 155],
          [190, 70, 190],
          [220, 110, 215],
          [245, 160, 240]
        ],
        gradient: true,
        fixedT: 0.78,
        glow: [255, 190, 250],
        edge: [70, 20, 90]
      },
      gradCitrus: {
        label: "Gradient Citrus",
        range: [
          [20, 30, 10],
          [45, 70, 20],
          [80, 120, 35],
          [120, 170, 55],
          [165, 210, 70],
          [200, 235, 90],
          [230, 255, 120]
        ],
        gradient: true,
        fixedT: 0.82,
        glow: [245, 255, 150],
        edge: [40, 60, 20]
      },
      gradRuby: {
        label: "Gradient Ruby",
        range: [
          [45, 6, 15],
          [90, 12, 30],
          [130, 20, 50],
          [170, 35, 70],
          [205, 60, 85],
          [235, 100, 100],
          [255, 150, 120]
        ],
        gradient: true,
        fixedT: 0.8,
        glow: [255, 180, 160],
        edge: [85, 18, 30]
      },
      gradSky: {
        label: "Gradient Cyan",
        range: [
          [10, 40, 90],
          [25, 70, 140],
          [40, 105, 190],
          [60, 140, 220],
          [85, 175, 240],
          [120, 205, 250],
          [160, 230, 255]
        ],
        gradient: true,
        fixedT: 0.82,
        glow: [185, 240, 255],
        edge: [20, 50, 90]
      },
      gradBlue: {
        label: "Gradient Blue",
        range: [
          [6, 20, 70],
          [12, 35, 110],
          [18, 55, 150],
          [28, 80, 190],
          [45, 110, 220],
          [70, 140, 245],
          [100, 175, 255]
        ],
        gradient: true,
        fixedT: 0.8,
        glow: [150, 200, 255],
        edge: [10, 30, 70]
      },
      solidAmber: {
        label: "Mono Amber",
        solid: [255, 177, 66],
        glow: [255, 210, 140],
        edge: [120, 70, 20]
      },
      solidCoral: {
        label: "Mono Coral",
        solid: [255, 115, 102],
        glow: [255, 175, 165],
        edge: [120, 50, 45]
      },
      solidMint: {
        label: "Mono Mint",
        solid: [120, 235, 200],
        glow: [170, 255, 225],
        edge: [40, 110, 95]
      },
      solidViolet: {
        label: "Mono Violet",
        solid: [176, 135, 255],
        glow: [210, 190, 255],
        edge: [70, 50, 120]
      },
      solidLime: {
        label: "Mono Lime",
        solid: [190, 255, 120],
        glow: [225, 255, 170],
        edge: [90, 120, 40]
      },
      solidSky: {
        label: "Mono Cyan",
        solid: [120, 210, 255],
        glow: [180, 240, 255],
        edge: [40, 100, 150]
      },
      solidBlue: {
        label: "Mono Blue",
        solid: [70, 130, 255],
        glow: [130, 180, 255],
        edge: [20, 50, 120]
      },
      heightHeat: {
        label: "Height Heat",
        range: [
          [50, 6, 8],
          [100, 20, 20],
          [150, 35, 20],
          [200, 60, 20],
          [230, 110, 30],
          [250, 170, 60],
          [255, 225, 110]
        ],
        gradient: true,
        glow: [255, 210, 140],
        edge: [90, 20, 20]
      },
      heightAurora: {
        label: "Height Aurora",
        range: [
          [8, 40, 60],
          [12, 70, 110],
          [20, 110, 170],
          [30, 140, 210],
          [45, 170, 235],
          [70, 200, 245],
          [110, 230, 255]
        ],
        gradient: true,
        glow: [180, 250, 255],
        edge: [10, 40, 70]
      },
      heightPlasma: {
        label: "Height Plasma",
        range: [
          [30, 5, 60],
          [60, 15, 110],
          [90, 30, 160],
          [130, 50, 200],
          [170, 80, 230],
          [210, 120, 245],
          [240, 170, 255]
        ],
        gradient: true,
        glow: [240, 190, 255],
        edge: [60, 20, 100]
      },
      heightCopper: {
        label: "Height Copper",
        range: [
          [50, 25, 18],
          [85, 40, 22],
          [120, 60, 30],
          [160, 85, 38],
          [190, 120, 55],
          [215, 155, 80],
          [235, 190, 120]
        ],
        gradient: true,
        glow: [255, 210, 170],
        edge: [90, 50, 30]
      },
      heightIcefire: {
        label: "Height Icefire",
        range: [
          [10, 60, 90],
          [15, 90, 150],
          [30, 130, 210],
          [80, 170, 235],
          [140, 120, 230],
          [190, 80, 215],
          [240, 60, 200]
        ],
        gradient: true,
        glow: [210, 200, 255],
        edge: [20, 60, 90]
      },
      heightSky: {
        label: "Height Cyan",
        range: [
          [12, 55, 110],
          [20, 85, 160],
          [35, 120, 200],
          [55, 155, 225],
          [85, 185, 240],
          [120, 210, 250],
          [160, 230, 255]
        ],
        gradient: true,
        glow: [185, 235, 255],
        edge: [20, 60, 110]
      },
      heightBlue: {
        label: "Height Blue",
        range: [
          [8, 30, 90],
          [15, 50, 130],
          [25, 70, 170],
          [40, 95, 205],
          [60, 125, 230],
          [85, 155, 245],
          [120, 185, 255]
        ],
        gradient: true,
        glow: [150, 205, 255],
        edge: [10, 40, 90]
      }
    };

  const paletteKey = paletteEl?.value || "solidBlue";
  const palette = palettes[paletteKey] || palettes.gradSunrise;
  const colorRange = palette.range;

const COLOR_CAP = 12; // 12+ будет просто самым насыщенным
    const clamp01 = (n) => Math.max(0, Math.min(1, n));
    const lerp = (a, b, t) => Math.round(a + (b - a) * t);
    function colorFor(v) {
      if (palette.solid) {
        return palette.solid;
      }
      const t = clamp01(v / COLOR_CAP);
      if (palette.gradient) {
        const scaled = t * (colorRange.length - 1);
        const idx = Math.floor(scaled);
        const mix = scaled - idx;
        const c1 = colorRange[idx];
        const c2 = colorRange[Math.min(idx + 1, colorRange.length - 1)];
        return [
          lerp(c1[0], c2[0], mix),
          lerp(c1[1], c2[1], mix),
          lerp(c1[2], c2[2], mix)
        ];
      }
      const idx = Math.floor(t * (colorRange.length - 1));
      return colorRange[idx];
    }

  return new PolygonLayer({
    id: "h3-polygons",
    data: cellsNow, // [{cell, count}]
    updateTriggers: {
      getElevation: [frameTick, elevEl.value, logToggleEl.checked, h3resEl.value],
      getFillColor: [frameTick, logToggleEl.checked, paletteKey],
      getLineColor: [frameTick, logToggleEl.checked, paletteKey]
    },
    // h3 boundary -> polygon (lon/lat)
    getPolygon: d => {
        const boundary = h3.cellToBoundary(d.cell, true); // true => GeoJSON order [lng, lat]
        return boundary.map(([lng, lat]) => [lng, lat]);  // deck.gl ждёт [lon, lat] = [lng, lat]

    },
      transitions: {
  getElevation: {
    duration: 700,
    easing: d3.easeCubicOut
  }
},

extruded: true,
stroked: true,
filled: true,
wireframe: false,
getElevation: d => d.count === 0 ? 0 : (BASE_ELEV + transform(d.count)) * elevationScale,
getFillColor: d => {
  // 0 не рисуем, чтобы не было "плитки" в море/пустоте
  if (d.count === 0) return [0, 0, 0, 0];

  const v = palette.fixedT != null ? COLOR_CAP * palette.fixedT : transform(d.count);
  const [r, g, b] = colorFor(v);
  const now = performance.now();
  const glow =
    d.glowStart &&
    d.glowUntil &&
    now >= d.glowStart &&
    now <= d.glowUntil
      ? Math.max(0, (d.glowUntil - now) / GLOW_DURATION_MS)
      : 0;
  const glowMix = Math.min(1, glow * 1.15);
  const [gr, gg, gb] = palette.glow;
  const mix = (base, boost) => Math.round(base + (boost - base) * glowMix);
  const alpha = Math.round(255 * (0.9 + glowMix * 0.1));
  return [mix(r, gr), mix(g, gg), mix(b, gb), alpha];
},

getLineColor: d => {
  // "точки" (контур) делаем полностью чёрными
  if (d.count === 0) return [0, 0, 0, 0];
  const now = performance.now();
  const glow =
    d.glowStart &&
    d.glowUntil &&
    now >= d.glowStart &&
    now <= d.glowUntil
      ? Math.max(0, (d.glowUntil - now) / GLOW_DURATION_MS)
      : 0;
  const glowMix = Math.min(1, glow * 1.15);
  const [gr, gg, gb] = palette.glow;
  const [er, eg, eb] = palette.edge || [20, 28, 40];
  const mix = (base, boost) => Math.round(base + (boost - base) * glowMix);
  const glowAlpha = Math.round(160 + glow * 90);
  return [mix(er, gr), mix(eg, gg), mix(eb, gb), glowAlpha];
},

lineWidthMinPixels: 1.5,


    opacity: 0.99,
    pickable: true,
    wireframe: false,
    material: {
  ambient: 0.12,
  diffuse: 0.55,
  shininess: 80,
  specularColor: [255, 255, 255]
}
  });
}


  function updateOverlay() {
    overlay.setProps({layers: [makeLayer()]});
  }

  // Timeline build (stable hex bins)
  async function rebuildTimeline() {
    stopPlayback();
    const token = ++buildToken;

    // Rebuild stable registry from scratch on every timeline rebuild.
    // This prevents new hex objects from being created mid-playback (which would "pop" in).
    cellRegistry.clear();
    stableCells = [];

    // collect unique months + min/max for full range
    let minMonth = null;
    let maxMonth = null;
    for (const p of filteredPoints) {
      if (p.tMonthMs == null) continue;
      if (minMonth == null || p.tMonthMs < minMonth) minMonth = p.tMonthMs;
      if (maxMonth == null || p.tMonthMs > maxMonth) maxMonth = p.tMonthMs;
    }
    months = buildMonthRange(minMonth, maxMonth);

    if (!months.length) {
      sliderEl.disabled = true;
      sliderEl.min = "0"; sliderEl.max = "0"; sliderEl.value = "0";
      timeLabelEl.textContent = "—";
      stepsLabelEl.textContent = "0 steps";
      shownPillEl.textContent = "0 shown";
      // вместо пустоты показываем базовую сетку UK
       try {
          const res = Number(h3resEl.value);
           // ВАЖНО: чтобы новые гексы не "появлялись", а росли 0→N,
// регистрируем все ячейки, которые могут возникнуть из данных.
seedRegistryFromPoints(filteredPoints, res);
          await ensureBaseGridFromPoints(res);
          cellsNow = stableCells;
        } catch (e) {
          console.warn("Base grid (bbox) failed:", e);
          cellsNow = [];
        }

      updateOverlay();
      setStat("Нет @timestamp в данных (или он не распарсился). Нужен properties['@timestamp'] из Overpass meta.");
      return;
    }

    // index months
    monthIndexByMs = new Map(months.map((ms, i) => [ms, i]));

    // prepare accumulative maps
    h3ByMonth = Array.from({length: months.length}, () => new Map());

    const res = Number(h3resEl.value);

    // Pre-register all cells that can appear, so elevation transitions work as 0→N instead of popping in.
    seedRegistryFromPoints(filteredPoints, res);

    // base grid from points bbox (no external fetch)
    try {
      await ensureBaseGridFromPoints(res);
    } catch (e) {
      console.warn("Base grid (bbox) failed:", e);
    }

    if (token !== buildToken) return;

    // fill accumulative counts
    for (const p of filteredPoints) {
      if (p.tMonthMs == null) continue;

      const idx = monthIndexByMs.get(p.tMonthMs);
      if (idx == null) continue;

      const [lon, lat] = p.coordinates;
      const cell = h3.latLngToCell(lat, lon, res);

      // add this point to its month and all future months (accumulative)
      for (let j = idx; j < months.length; j++) {
        const m = h3ByMonth[j];
        m.set(cell, (m.get(cell) || 0) + 1);
      }
    }

    sliderEl.disabled = false;
    sliderEl.min = "0";
    sliderEl.max = String(months.length - 1);
    sliderEl.value = "0";
    stepsLabelEl.textContent = `${months.length} steps`;
    const startEl = document.getElementById("startLabel");
    const endEl = document.getElementById("endLabel");
    if (startEl) startEl.textContent = formatDayText(months[0]);
    if (endEl) endEl.textContent = formatDayText(months[months.length-1]);

    applyTimeline(0);

    setStat(`Points: ${allPoints.length}. After search: ${filteredPoints.length}. Timeline steps: ${months.length} (by month). H3 res: ${res}.`);
    console.log("months:", months.length, "cellsNow sample:", cellsNow.slice(0,3));

  }

  function applyTimeline(idx) {
    const t = months[idx];
    renderTimeLabel(t);

    const m = h3ByMonth[idx] || new Map();

    // Update stable objects (reuse across frames) so transitions are smooth.
    // First set all known cells to 0, then apply counts for this frame.
    for (const obj of stableCells) {
      obj.prevCount = obj.count || 0;
      obj.count = 0;
    }
    for (const [cell, count] of m.entries()) {
      const obj = cellRegistry.get(cell);
      if (!obj) continue; // never create new cells during playback
      obj.count = count;
    }

    const now = performance.now();
    let latestGlow = 0;
    for (const obj of stableCells) {
      if (obj.count > (obj.prevCount || 0)) {
        obj.glowStart = now + GLOW_DELAY_MS;
        obj.glowUntil = obj.glowStart + GLOW_DURATION_MS;
      }
      if (obj.glowUntil && obj.glowUntil > latestGlow) {
        latestGlow = obj.glowUntil;
      }
    }
    glowActiveUntil = Math.max(glowActiveUntil, latestGlow);
    startGlowTicker();

    // IMPORTANT: deck.gl transitions are triggered when the `data` prop changes.
    // We keep stable object identities (so values can tween), but pass a new
    // array reference each frame so attributes re-evaluate and animate.
    cellsNow = stableCells.slice();
    frameTick++;


    const total = Array.from(m.values()).reduce((s, v) => s + v, 0);
    shownPillEl.textContent = `${total} shown`;

    updateOverlay();
  }

  function startGlowTicker() {
    if (glowTicker) return;
    const tick = () => {
      const now = performance.now();
      if (now - lastGlowUpdate >= GLOW_UPDATE_INTERVAL_MS) {
        frameTick++;
        updateOverlay();
        lastGlowUpdate = now;
      }
      if (now < glowActiveUntil) {
        glowTicker = requestAnimationFrame(tick);
      } else {
        glowTicker = null;
      }
    };
    glowTicker = requestAnimationFrame(tick);
  }

  // Playback
  function stopPlayback() {
    playing = false;
    playBtn.textContent = "▶";
    if (timer) { clearInterval(timer); timer = null; }
  }
  function startPlayback() {
    if (!months.length) return;
    playing = true;
    playBtn.textContent = "❚❚";
    timer = setInterval(() => {
      const v = Number(sliderEl.value);
      if (v >= months.length - 1) { stopPlayback(); return; }
      sliderEl.value = String(v + 1);
      applyTimeline(Number(sliderEl.value));
    }, PLAY_INTERVAL_MS);
  }

  // UI wiring
  sliderEl.addEventListener("input", () => { stopPlayback(); applyTimeline(Number(sliderEl.value)); });
  playBtn.addEventListener("click", () => { if (!months.length) return; playing ? stopPlayback() : startPlayback(); });

  elevEl.addEventListener("input", () => { setVals(); updateOverlay(); });
  logToggleEl.addEventListener("change", () => { updateOverlay(); });
  paletteEl.addEventListener("change", () => { setVals(); updateOverlay(); });

  if (togglePanelEl && panelEl) {
    togglePanelEl.addEventListener("click", () => {
      const collapsed = panelEl.classList.toggle("panel--collapsed");
      togglePanelEl.textContent = collapsed ? "⟩" : "⟨";
      togglePanelEl.setAttribute("aria-label", collapsed ? "Expand panel" : "Collapse panel");
      togglePanelEl.setAttribute("title", collapsed ? "Expand panel" : "Collapse panel");
    });
  }

  h3resEl.addEventListener("change", () => {
    setVals();
    // rebuild bins with new resolution so they remain stable
    rebuildTimeline();
  });

  // Search removed

  
  document.getElementById("clear").addEventListener("click", () => {
    stopPlayback();
    allPoints=[]; filteredPoints=[]; months=[]; monthIndexByMs=new Map(); h3ByMonth=[]; cellsNow=[];
    fileEl.value="";
    sliderEl.disabled=true; sliderEl.min="0"; sliderEl.max="0"; sliderEl.value="0";
    timeLabelEl.textContent="—"; stepsLabelEl.textContent="0 steps"; shownPillEl.textContent="0 shown";
    setStat("Cleared.");
    updateOverlay();
  });

  document.getElementById("fit").addEventListener("click", () => {
    const b = boundsFromPoints(filteredPoints);
    if (!b) return;
    const [minLon,minLat,maxLon,maxLat] = b;
    map.fitBounds([[minLon, minLat], [maxLon, maxLat]], {padding: 60, duration: 600});
  });

  function loadGeoJSONData(geo, sourceLabel) {
    const raw = extractPointsFromGeoJSON(geo);

    if (!raw.length) {
      setStat("Файл загрузился, но точек нет. Проверь, что GeoJSON содержит Point-геометрии.");
      return;
    }

    allPoints = raw.map(p => {
      const props = p.properties || {};
      const ts = getProp(props, ["@timestamp", "timestamp"]);
      const ms = ts ? parseTimestampToMs(ts) : null;
      return {
        coordinates: p.coordinates,
        properties: props,
        tMonthMs: (ms != null) ? toMonthMs(ms) : null
      };
    }).filter(p => Array.isArray(p.coordinates) && typeof p.coordinates[0] === "number" && typeof p.coordinates[1] === "number");

    filteredPoints = [...allPoints];
    rebuildTimeline();

    const b = boundsFromPoints(filteredPoints);
    if (b) {
      const [minLon,minLat,maxLon,maxLat] = b;
      map.fitBounds([[minLon, minLat], [maxLon, maxLat]], {padding: 60, duration: 600});
    }

    setVals();
    updateOverlay();
    if (sourceLabel) {
      setStat(`Loaded: ${sourceLabel}. Points: ${allPoints.length}.`);
    }
  }

  // Load file from local computer
  fileEl.addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if (!f) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const geo = JSON.parse(reader.result);
        loadGeoJSONData(geo, f.name);
      } catch (err) {
        console.error(err);
        alert("Не удалось распарсить JSON/GeoJSON.");
      }
    };
    reader.readAsText(f);
  });

  // Load file from server (click button)
  document.querySelectorAll(".server-file").forEach((btn) => {
    btn.addEventListener("click", async () => {
      const fileName = btn.getAttribute("data-file");
      if (!fileName) return;
      try {
        const res = await fetch(fileName, {cache: "no-store"});
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const geo = await res.json();
        loadGeoJSONData(geo, `server/${fileName}`);
      } catch (err) {
        console.error(err);
        alert("Не удалось загрузить файл с сервера.");
      }
    });
  });

    map.on("load", async () => {
      setStat("Выбери uk-datacenters.geojson. Совет: log выключен = строго линейные высоты.");

      // Всегда строим базовую сетку и показываем её с нулевыми значениями
      try {
        const res = Number(h3resEl.value);
        await ensureBaseGrid(res);
        cellsNow = stableCells; // все клетки UK (count=0)
        updateOverlay();
      } catch (e) {
        console.warn("Base grid init failed:", e);
        updateOverlay();
      }
    });

</script>
</body>
</html>
