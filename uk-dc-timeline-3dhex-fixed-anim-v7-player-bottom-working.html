<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>UK DC timeline (MapLibre + deck.gl + H3)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- deck.gl -->
  <script src="https://unpkg.com/deck.gl@8.9.36/dist.min.js"></script>

  <!-- H3 (stable hex indexing) -->
  <script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>
<script src="https://unpkg.com/d3-ease@3"></script>
    
  <style>
    html, body { margin:0; height:100%; background:#f6f8fc; font:14px system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #container { position:relative; height:100%; }
    #map { position:absolute; inset:0; }

    .panel {
      position:absolute; z-index:1000; left:16px; top:16px;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 12px 14px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: 14px;
      box-shadow: 0 14px 40px rgba(15, 23, 42, 0.12);
      max-width: 480px;
    }
    .title { display:flex; align-items:center; justify-content: space-between; gap: 12px; }
    .title h1 { font-size: 14px; margin: 0; font-weight: 650; color: #0f172a; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn {
      border: 1px solid rgba(15, 23, 42, 0.12);
      background:#fff; padding:7px 10px; border-radius:10px;
      cursor:pointer; user-select:none; color:#0f172a;
    }
    input[type="text"]{
      border:1px solid rgba(15,23,42,0.12);
      padding:7px 10px; border-radius:10px;
      width:220px; outline:none;
    }
    input[type="range"]{ width:100%; }
    .pill{
      display:inline-block; padding:3px 10px;
      border:1px solid rgba(15,23,42,0.10);
      border-radius:999px; background:rgba(255,255,255,0.9);
      font-size:12px; color:#0f172a; white-space:nowrap;
    }
    .dot{ width:10px; height:10px; border-radius:999px;
      background: rgb(38,124,255);
      box-shadow:0 0 0 6px rgba(38,124,255,0.12);
      display:inline-block; margin-right:8px;
    }
    .timeline { margin-top:10px; padding-top:10px; border-top:1px solid rgba(15,23,42,0.08); display:grid; gap:10px; }
    .timeinfo{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:#0f172a; }
    .twoCols{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .labelRow{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .muted{ color:#475569; font-size:12px; margin-top:8px; }
    .stat{ margin-top:10px; font-size:12px; color:#0f172a; }
    .select {
      border:1px solid rgba(15,23,42,0.12);
      background:#fff;
      padding:7px 10px;
      border-radius:10px;
      color:#0f172a;
      outline:none;
    }
  
    /* Infographic feel: лёгкое свечение/смягчение именно для deck.gl слоя */
    canvas.deckgl-overlay, .deckgl-overlay canvas {
      filter:
        drop-shadow(0 0 6px rgba(0, 125, 255, 0.22))
        drop-shadow(0 0 18px rgba(0, 125, 255, 0.10));
    }


    /* Player dock */
    .playerDock{
      position:absolute;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      z-index:1200;
      pointer-events:none; /* allow map interactions around it */
      width:min(720px, calc(100vw - 40px));
    }
    .playerCard{
      pointer-events:auto;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(15, 23, 42, 0.10);
      border-radius: 16px;
      box-shadow: 0 14px 40px rgba(15, 23, 42, 0.18);
      padding: 10px 12px;
    }
    .playerTopRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .playerSlider{ width:100%; margin:8px 0 6px; }
    .playerLabels{ display:flex; justify-content:space-between; gap:10px; font-size:12px; color:#0f172a; }
    .pillGhost{ opacity:0.8; }
    .pillBig{ font-size:12px; padding:4px 12px; }
    .btnIcon{ width:38px; height:38px; border-radius:12px; padding:0; display:grid; place-items:center; }
    .btnPlayIcon{ width:46px; height:46px; border-radius:14px; padding:0; display:grid; place-items:center; font-size:16px; }
      .current-date {
  font-size: 24px;
  font-weight: 400;
  letter-spacing: 0.03em;
  color: #000;

  /* убираем всё "UI-шное" */
  background: none;
  border: none;
  box-shadow: none;
  padding: 0;
  border-radius: 0;

  /* чуть воздуха */
  line-height: 1.2;
}
</style>
</head>

<body>
<div id="container">
  <div id="map"></div>

  <div class="panel">
    <div class="title">
      <h1><span class="dot"></span>Data centers timeline (3D hex)</h1>
      <span id="shownPill" class="pill">0 shown</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <input id="file" type="file" accept=".geojson,.json" class="btn">
      <button id="clear" class="btn" type="button">Clear</button>
      <button id="fit" class="btn" type="button">Fit</button>
    </div>
    <div class="row" style="margin-top:8px;">
      <select id="serverFile" class="select" aria-label="Server data">
        <option value="DC-UK.geojson" selected>DC-UK.geojson (server)</option>
        <option value="DC-global.geojson">DC-global.geojson (server)</option>
      </select>
      <button id="loadServer" class="btn" type="button">Load from server</button>
    </div>
<div class="settings">
      <div class="twoCols">
        <div>
          <div class="labelRow">
            <span class="pill">H3 resolution</span>
            <span id="resVal" class="pill">6</span>
          </div>
          <select id="h3res" class="select">
            <option value="5">5 (coarse)</option>
            <option value="6" selected>6 (default)</option>
            <option value="7">7 (detailed)</option>
            <option value="8">8 (very detailed)</option>
          </select>
        </div>

        <div>
          <div class="labelRow">
            <span class="pill">Elevation</span>
            <span id="elevVal" class="pill">x240</span>
          </div>
          <input id="elev" type="range" min="40" max="12000" step="20" value="8000">
        </div>
      </div>
      <div style="margin-top:10px;">
        <div class="labelRow">
          <span class="pill">Palette</span>
          <span id="paletteVal" class="pill">Monoblu</span>
        </div>
        <select id="palette" class="select" style="width:100%;">
          <option value="monoblue" selected>Monoblu (dark map)</option>
          <option value="monoIce">Monoblu Ice (dark map)</option>
          <option value="monoDeep">Monoblu Deep (dark map)</option>
          <option value="monoNeon">Monoblu Neon (dark map)</option>
          <option value="monoRoyal">Monoblu Royal (dark map)</option>
          <option value="monoSoft">Monoblu Soft (dark map)</option>
          <option value="latSunrise">Latitude Sunrise (gradient)</option>
          <option value="latLagoon">Latitude Lagoon (gradient)</option>
          <option value="latCitrus">Latitude Citrus (gradient)</option>
          <option value="latAurora">Latitude Aurora (gradient)</option>
          <option value="latBerry">Latitude Berry (gradient)</option>
          <option value="monoLime">Mono Lime (contrast)</option>
          <option value="monoMagenta">Mono Magenta (contrast)</option>
          <option value="monoAmber">Mono Amber (contrast)</option>
          <option value="monoTeal">Mono Teal (contrast)</option>
          <option value="monoCoral">Mono Coral (contrast)</option>
          <option value="heightViolet">Height Violet (gradient)</option>
          <option value="heightTropic">Height Tropic (gradient)</option>
          <option value="heightEmber">Height Ember (gradient)</option>
          <option value="heightMint">Height Mint (gradient)</option>
          <option value="heightRoyal">Height Royal (gradient)</option>
        </select>
      </div>

      <div class="row" style="justify-content: space-between; margin-top:10px;">
        <span class="pill">Distribution</span>
        <label class="pill" style="display:flex; align-items:center; gap:8px; cursor:pointer;">
          <input id="logToggle" type="checkbox">
          log(1 + count)
        </label>
      </div>
    </div>
</div>
    <div id="stat" class="stat" style="display:none"></div>

  </div>

  <!-- Center-bottom player dock -->
  <div class="playerDock" aria-label="Timeline player">
    <div class="playerCard">
      <div class="playerTopRow">
        <button id="rewind" class="btn btnIcon" type="button" title="Rewind">⟲</button>
          <span id="timeLabel" class="current-date">—</span>
        <button id="play" class="btn btnPlayIcon" type="button" aria-label="Play/Pause" title="Play/Pause">▶</button>
      </div>

      <input id="slider" class="playerSlider" type="range" min="0" max="0" value="0" step="1" disabled />

      <div class="playerLabels">
        <span id="startLabel" class="pill pillGhost">—</span>
        <span id="stepsLabel" class="pill pillGhost">0 steps</span>
        <span id="endLabel" class="pill pillGhost">—</span>
      </div>
    </div>
  </div>
</div>

<script>
  (function initApp() {
  if (!window.maplibregl) {
    console.error("maplibre-gl не загрузился");
    return;
  }

  // UI
  const statEl = document.getElementById("stat");
  const fileEl = document.getElementById("file");
const sliderEl = document.getElementById("slider");
  const timeLabelEl = document.getElementById("timeLabel");
  const stepsLabelEl = document.getElementById("stepsLabel");
  const shownPillEl = document.getElementById("shownPill");
  const playBtn = document.getElementById("play");
  const elevEl = document.getElementById("elev");
  const elevValEl = document.getElementById("elevVal");
  const logToggleEl = document.getElementById("logToggle");
  const h3resEl = document.getElementById("h3res");
  const resValEl = document.getElementById("resVal");
  const paletteEl = document.getElementById("palette");
  const paletteValEl = document.getElementById("paletteVal");
  const serverFileEl = document.getElementById("serverFile");

  function setStat(t){ if (statEl) statEl.textContent = t || ""; }

  if (!window.deck) {
    console.error("deck.gl не загрузился");
    setStat("deck.gl не загрузился. Проверь доступ к CDN.");
    return;
  }

  const h3 = window.h3 || window.h3js;
  if (!h3) {
    console.error("h3-js не загрузился");
    setStat("h3-js не загрузился. Проверь доступ к CDN.");
    return;
  }

  const {MapboxOverlay, PolygonLayer} = deck;

  // Basemap style
  const STYLE_URL = "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json";

  const map = new maplibregl.Map({
    container: "map",
    style: STYLE_URL,
    center: [-3.0, 54.5],
    zoom: 5.8,
    pitch: 68,
    bearing: -12,
    antialias: true
  });
  map.addControl(new maplibregl.NavigationControl({showCompass: true}), "top-right");
  function setVals(){
    elevValEl.textContent = `x${Number(elevEl.value)}`;
    resValEl.textContent = String(h3resEl.value);
    if (paletteValEl) {
      const selected = paletteEl?.selectedOptions?.[0];
      paletteValEl.textContent = selected ? selected.textContent.replace(" (dark map)", "") : "—";
    }
  }
  setVals();

  // Data:
  // point: {coordinates:[lon,lat], properties, tDayMs}
  let allPoints = [];
  let filteredPoints = [];

  // timeline days (UTC day)
  let days = [];
  let dayIndexByMs = new Map();
  let dataLatRange = { min: -90, max: 90 };

  // accumulative counts per day: Array<Map<h3Cell, count>>
  let h3ByDay = [];

  // layer data for current frame: [{cell, count}]
  let cellsNow = [];
  // Stable registry: cell -> object reused across frames
    const cellRegistry = new Map(); // cell -> {cell, count}
    let stableCells = [];           // stable array passed to deck.gl
  

  // Base grid (so 0-count hexes still render)
  const UK_GEOJSON_URL = "https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson";
  let ukFeature = null;                 // GeoJSON feature for UK
  const baseGridByRes = new Map();      // res -> array of h3 cell ids
  let buildToken = 0;

  async function ensureUKFeature() {
    if (ukFeature) return ukFeature;
    const r = await fetch(UK_GEOJSON_URL);
    if (!r.ok) throw new Error("Failed to fetch UK GeoJSON: " + r.status);
    const gj = await r.json();
    const f = gj.features.find(ft => {
      const nm = (ft.properties?.ADMIN || ft.properties?.name || "").toLowerCase();
      return nm === "united kingdom";
    });
    if (!f) throw new Error("UK feature not found in countries.geojson");
    ukFeature = f;
    return ukFeature;
  }
                  
  function seedRegistryFromPoints(points, res) {
  for (const p of points) {
    const [lon, lat] = p.coordinates || [];
    if (typeof lon !== "number" || typeof lat !== "number") continue;

    const cell = h3.latLngToCell(lat, lon, res);
    if (!cellRegistry.has(cell)) cellRegistry.set(cell, { cell, count: 0 });
  }
  stableCells = Array.from(cellRegistry.values());
}

  function swapLonLatToLatLon(geom) {
    // GeoJSON uses [lon,lat]; h3-js expects [lat,lon]
    if (geom.type === "Polygon") {
      return { type: "Polygon", coordinates: geom.coordinates.map(ring => ring.map(([lon, lat]) => [lat, lon])) };
    }
    if (geom.type === "MultiPolygon") {
      return { type: "MultiPolygon", coordinates: geom.coordinates.map(poly => poly.map(ring => ring.map(([lon, lat]) => [lat, lon]))) };
    }
    throw new Error("Unsupported geometry type: " + geom.type);
  }

  async function ensureBaseGrid(res) {
    if (baseGridByRes.has(res)) return baseGridByRes.get(res);
    const uk = await ensureUKFeature();
    const swapped = swapLonLatToLatLon(uk.geometry);
    const cells = h3.polygonToCells(swapped, res);
    baseGridByRes.set(res, cells);

    // register all cells as stable objects with count=0
    for (const cell of cells) {
      if (!cellRegistry.has(cell)) cellRegistry.set(cell, { cell, count: 0 });
    }
    stableCells = Array.from(cellRegistry.values());
    return cells;
  }

  // playback
  let playing = false;
  let timer = null;
  const PLAY_INTERVAL_MS = 220;
  let frameTick = 0; // increments each frame to force attribute updates & transitions
  let glowTicker = null;
  let glowActiveUntil = 0;
  let lastGlowUpdate = 0;
  const GLOW_DURATION_MS = 1200;
  const GLOW_DELAY_MS = 140;
  const GLOW_UPDATE_INTERVAL_MS = 70;

  // Helpers
  function getProp(p, keys) { for (const k of keys) if (p && p[k] != null && p[k] !== "") return p[k]; return ""; }
  function parseTimestampToMs(ts) { const d = new Date(ts); const ms = d.getTime(); return Number.isFinite(ms) ? ms : null; }
  function toDayMs(ms) { const d = new Date(ms); return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()); }
  function fmtDay(ms) {
    const d = new Date(ms);
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth() + 1).padStart(2, "0");
    const day = String(d.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }
  function extractPointsFromGeoJSON(geo) {
    const pts = [];
    const feats = geo?.type === "FeatureCollection" ? (geo.features || []) :
                  geo?.type === "Feature" ? [geo] : [];
    for (const f of feats) {
      const g = f.geometry;
      if (!g) continue;
      if (g.type === "Point" && Array.isArray(g.coordinates)) {
        pts.push({ coordinates: g.coordinates, properties: f.properties || {} });
      }
    }
    return pts;
  }
  function boundsFromPoints(points) {
    let minLon = 180, minLat = 90, maxLon = -180, maxLat = -90, ok = false;
    for (const p of points) {
      const [lon, lat] = p.coordinates || [];
      if (typeof lon !== "number" || typeof lat !== "number") continue;
      ok = true;
      minLon = Math.min(minLon, lon); maxLon = Math.max(maxLon, lon);
      minLat = Math.min(minLat, lat); maxLat = Math.max(maxLat, lat);
    }
    return ok ? [minLon, minLat, maxLon, maxLat] : null;
  }
    
    function bboxToLatLonPolygon(b, padDeg = 0.6) {
  const [minLon, minLat, maxLon, maxLat] = b;
  const a = minLon - padDeg, btm = minLat - padDeg;
  const c = maxLon + padDeg, top = maxLat + padDeg;

  // h3-js polygonToCells ждёт [lat, lon]
  return {
    type: "Polygon",
    coordinates: [[
      [btm, a],
      [btm, c],
      [top, c],
      [top, a],
      [btm, a]
    ]]
  };
}

async function ensureBaseGridFromPoints(res) {
  const b = boundsFromPoints(filteredPoints.length ? filteredPoints : allPoints);
  if (!b) return [];

  const poly = bboxToLatLonPolygon(b, 0.8); // pad можно увеличить
  const cells = h3.polygonToCells(poly, res);

  // регистрируем все клетки в реестре как стабильные объекты count=0
  for (const cell of cells) {
    if (!cellRegistry.has(cell)) cellRegistry.set(cell, { cell, count: 0 });
  }
  stableCells = Array.from(cellRegistry.values());
  return cells;
}


  // Overlay
  const overlay = new MapboxOverlay({layers: []});
  map.addControl(overlay);

function makeLayer() {
  const elevationScale = Number(elevEl.value); // высота за 1 DC
  const useLog = !!logToggleEl.checked;
  const transform = (n) => useLog ? Math.log1p(n) : n;
    
    const BASE_ELEV = 0.18; // минимальная высота (до умножения на elevationScale)
    const FILL_ALPHA = 255; // полностью непрозрачные бары
    const LINE_ALPHA = 90;  // контур чуть мягче
    const LINE_WIDTH = 1.3; // px
    const palettes = {
      monoblue: {
        label: "Monoblu",
        range: [
          [0, 140, 255],
          [0, 140, 255],
          [0, 140, 255],
          [0, 140, 255],
          [0, 140, 255],
          [0, 140, 255],
          [0, 140, 255]
        ],
        glow: [255, 255, 255],
        edge: [220, 240, 255],
        mode: "fixed"
      },
      monoIce: {
        label: "Monoblu Ice",
        range: [
          [200, 240, 255],
          [170, 230, 255],
          [130, 215, 255],
          [95, 195, 255],
          [70, 170, 245],
          [50, 145, 225],
          [35, 120, 205]
        ],
        glow: [220, 255, 255],
        edge: [180, 210, 230],
        mode: "fixed"
      },
      monoDeep: {
        label: "Monoblu Deep",
        range: [
          [4, 16, 48],
          [8, 28, 72],
          [12, 40, 96],
          [16, 60, 128],
          [26, 80, 160],
          [38, 105, 190],
          [58, 130, 215]
        ],
        glow: [120, 190, 255],
        edge: [6, 12, 26],
        mode: "fixed"
      },
      monoNeon: {
        label: "Monoblu Neon",
        range: [
          [5, 70, 150],
          [0, 110, 200],
          [0, 150, 230],
          [0, 185, 255],
          [35, 210, 255],
          [80, 235, 255],
          [130, 255, 255]
        ],
        glow: [160, 255, 255],
        edge: [0, 80, 160],
        mode: "fixed"
      },
      monoRoyal: {
        label: "Monoblu Royal",
        range: [
          [30, 35, 100],
          [40, 55, 140],
          [55, 75, 180],
          [70, 95, 210],
          [90, 120, 235],
          [120, 150, 255],
          [160, 190, 255]
        ],
        glow: [190, 215, 255],
        edge: [28, 34, 90],
        mode: "fixed"
      },
      monoSoft: {
        label: "Monoblu Soft",
        range: [
          [210, 230, 255],
          [180, 210, 250],
          [150, 195, 245],
          [120, 175, 235],
          [95, 155, 225],
          [70, 135, 210],
          [55, 115, 190]
        ],
        glow: [210, 240, 255],
        edge: [150, 180, 210],
        mode: "fixed"
      },
      latSunrise: {
        label: "Latitude Sunrise",
        gradient: true,
        range: [
          [255, 205, 145],
          [255, 170, 120],
          [255, 130, 110],
          [230, 95, 125],
          [190, 80, 155],
          [140, 70, 190],
          [100, 70, 220]
        ],
        glow: [255, 220, 170],
        edge: [255, 185, 140],
        mode: "lat"
      },
      latLagoon: {
        label: "Latitude Lagoon",
        gradient: true,
        range: [
          [190, 255, 245],
          [130, 235, 245],
          [90, 210, 235],
          [70, 180, 225],
          [60, 150, 210],
          [50, 120, 195],
          [40, 95, 175]
        ],
        glow: [200, 255, 255],
        edge: [120, 200, 220],
        mode: "lat"
      },
      latCitrus: {
        label: "Latitude Citrus",
        gradient: true,
        range: [
          [255, 235, 160],
          [255, 215, 110],
          [255, 190, 70],
          [250, 160, 60],
          [240, 130, 70],
          [220, 95, 85],
          [190, 70, 110]
        ],
        glow: [255, 230, 170],
        edge: [240, 180, 100],
        mode: "lat"
      },
      latAurora: {
        label: "Latitude Aurora",
        gradient: true,
        range: [
          [180, 255, 210],
          [130, 245, 200],
          [95, 225, 205],
          [80, 195, 215],
          [70, 165, 220],
          [75, 135, 220],
          [90, 110, 210]
        ],
        glow: [200, 255, 230],
        edge: [110, 200, 210],
        mode: "lat"
      },
      latBerry: {
        label: "Latitude Berry",
        gradient: true,
        range: [
          [255, 210, 240],
          [240, 175, 240],
          [220, 135, 230],
          [190, 110, 220],
          [150, 90, 210],
          [120, 80, 200],
          [95, 75, 180]
        ],
        glow: [255, 220, 250],
        edge: [200, 140, 220],
        mode: "lat"
      },
      monoLime: {
        label: "Mono Lime",
        range: [
          [140, 255, 120],
          [140, 255, 120],
          [140, 255, 120],
          [140, 255, 120],
          [140, 255, 120],
          [140, 255, 120],
          [140, 255, 120]
        ],
        glow: [200, 255, 200],
        edge: [120, 200, 120],
        mode: "fixed"
      },
      monoMagenta: {
        label: "Mono Magenta",
        range: [
          [255, 105, 235],
          [255, 105, 235],
          [255, 105, 235],
          [255, 105, 235],
          [255, 105, 235],
          [255, 105, 235],
          [255, 105, 235]
        ],
        glow: [255, 180, 250],
        edge: [210, 100, 200],
        mode: "fixed"
      },
      monoAmber: {
        label: "Mono Amber",
        range: [
          [255, 185, 70],
          [255, 185, 70],
          [255, 185, 70],
          [255, 185, 70],
          [255, 185, 70],
          [255, 185, 70],
          [255, 185, 70]
        ],
        glow: [255, 220, 140],
        edge: [220, 160, 60],
        mode: "fixed"
      },
      monoTeal: {
        label: "Mono Teal",
        range: [
          [80, 235, 220],
          [80, 235, 220],
          [80, 235, 220],
          [80, 235, 220],
          [80, 235, 220],
          [80, 235, 220],
          [80, 235, 220]
        ],
        glow: [170, 255, 245],
        edge: [70, 190, 180],
        mode: "fixed"
      },
      monoCoral: {
        label: "Mono Coral",
        range: [
          [255, 130, 120],
          [255, 130, 120],
          [255, 130, 120],
          [255, 130, 120],
          [255, 130, 120],
          [255, 130, 120],
          [255, 130, 120]
        ],
        glow: [255, 200, 190],
        edge: [220, 110, 100],
        mode: "fixed"
      },
      heightViolet: {
        label: "Height Violet",
        gradient: true,
        range: [
          [230, 220, 255],
          [200, 185, 255],
          [170, 150, 255],
          [145, 120, 245],
          [120, 95, 235],
          [100, 70, 220],
          [80, 50, 200]
        ],
        glow: [210, 190, 255],
        edge: [190, 170, 240],
        mode: "value"
      },
      heightTropic: {
        label: "Height Tropic",
        gradient: true,
        range: [
          [160, 255, 230],
          [115, 240, 215],
          [80, 220, 200],
          [60, 195, 205],
          [50, 170, 220],
          [55, 140, 230],
          [70, 110, 235]
        ],
        glow: [190, 255, 240],
        edge: [120, 210, 220],
        mode: "value"
      },
      heightEmber: {
        label: "Height Ember",
        gradient: true,
        range: [
          [255, 220, 190],
          [255, 190, 140],
          [255, 160, 100],
          [250, 130, 80],
          [235, 100, 70],
          [210, 75, 65],
          [180, 55, 55]
        ],
        glow: [255, 205, 160],
        edge: [240, 150, 100],
        mode: "value"
      },
      heightMint: {
        label: "Height Mint",
        gradient: true,
        range: [
          [210, 255, 235],
          [170, 250, 220],
          [130, 235, 210],
          [100, 215, 205],
          [80, 190, 200],
          [70, 165, 190],
          [60, 140, 175]
        ],
        glow: [210, 255, 240],
        edge: [140, 210, 190],
        mode: "value"
      },
      heightRoyal: {
        label: "Height Royal",
        gradient: true,
        range: [
          [210, 220, 255],
          [180, 190, 255],
          [150, 160, 250],
          [125, 130, 245],
          [105, 105, 235],
          [90, 85, 220],
          [75, 70, 200]
        ],
        glow: [200, 210, 255],
        edge: [170, 175, 240],
        mode: "value"
      }
    };

  const paletteKey = paletteEl?.value || "monoblue";
  const palette = palettes[paletteKey] || palettes.monoblue;
  const colorRange = palette.range;

const COLOR_CAP = 12; // 12+ будет просто самым насыщенным
    const clamp01 = (n) => Math.max(0, Math.min(1, n));
    const lerp = (a, b, t) => Math.round(a + (b - a) * t);
    function colorForT(t) {
      if (palette.gradient) {
        const scaled = clamp01(t) * (colorRange.length - 1);
        const idx = Math.floor(scaled);
        const mix = scaled - idx;
        const c1 = colorRange[idx];
        const c2 = colorRange[Math.min(idx + 1, colorRange.length - 1)];
        return [
          lerp(c1[0], c2[0], mix),
          lerp(c1[1], c2[1], mix),
          lerp(c1[2], c2[2], mix)
        ];
      }
      const idx = Math.floor(clamp01(t) * (colorRange.length - 1));
      return colorRange[idx];
    }
    function colorForValue(v) {
      const t = clamp01(v / COLOR_CAP);
      return colorForT(t);
    }
    function colorForLat(cell) {
      const [lat] = h3.cellToLatLng(cell);
      const span = dataLatRange.max - dataLatRange.min;
      const t = span > 0 ? (lat - dataLatRange.min) / span : 0.5;
      return colorForT(t);
    }

  return new PolygonLayer({
    id: "h3-polygons",
    data: cellsNow, // [{cell, count}]
    updateTriggers: {
      getElevation: [frameTick, elevEl.value, logToggleEl.checked, h3resEl.value],
      getFillColor: [frameTick, logToggleEl.checked, paletteKey],
      getLineColor: [frameTick, logToggleEl.checked, paletteKey]
    },
    // h3 boundary -> polygon (lon/lat)
    getPolygon: d => {
        const boundary = h3.cellToBoundary(d.cell, true); // true => GeoJSON order [lng, lat]
        return boundary.map(([lng, lat]) => [lng, lat]);  // deck.gl ждёт [lon, lat] = [lng, lat]

    },
      transitions: {
  getElevation: {
    duration: 700,
    easing: d3.easeCubicOut
  }
},

extruded: true,
stroked: true,
filled: true,
wireframe: false,
getElevation: d => d.count === 0 ? 0 : (BASE_ELEV + transform(d.count)) * elevationScale,
getFillColor: d => {
  // 0 не рисуем, чтобы не было "плитки" в море/пустоте
  if (d.count === 0) return [0, 0, 0, 0];

  const v = transform(d.count);
  let rgb;
  if (palette.mode === "lat") {
    rgb = colorForLat(d.cell);
  } else if (palette.mode === "fixed") {
    rgb = colorRange[0];
  } else {
    rgb = colorForValue(v);
  }
  const [r, g, b] = rgb;
  const now = performance.now();
  const glow =
    d.glowStart &&
    d.glowUntil &&
    now >= d.glowStart &&
    now <= d.glowUntil
      ? Math.max(0, (d.glowUntil - now) / GLOW_DURATION_MS)
      : 0;
  const glowMix = Math.min(1, glow * 1.15);
  const [gr, gg, gb] = palette.glow;
  const mix = (base, boost) => Math.round(base + (boost - base) * glowMix);
  const alpha = Math.round(255 * (0.9 + glowMix * 0.1));
  return [mix(r, gr), mix(g, gg), mix(b, gb), alpha];
},

getLineColor: d => {
  // "точки" (контур) делаем полностью чёрными
  if (d.count === 0) return [0, 0, 0, 0];
  const now = performance.now();
  const glow =
    d.glowStart &&
    d.glowUntil &&
    now >= d.glowStart &&
    now <= d.glowUntil
      ? Math.max(0, (d.glowUntil - now) / GLOW_DURATION_MS)
      : 0;
  const glowMix = Math.min(1, glow * 1.15);
  const [gr, gg, gb] = palette.glow;
  const [er, eg, eb] = palette.edge || [20, 28, 40];
  const mix = (base, boost) => Math.round(base + (boost - base) * glowMix);
  const glowAlpha = Math.round(160 + glow * 90);
  return [mix(er, gr), mix(eg, gg), mix(eb, gb), glowAlpha];
},

lineWidthMinPixels: 1.5,


    opacity: 0.99,
    pickable: true,
    wireframe: false,
    material: {
  ambient: 0.12,
  diffuse: 0.55,
  shininess: 80,
  specularColor: [255, 255, 255]
}
  });
}


  function updateOverlay() {
    overlay.setProps({layers: [makeLayer()]});
  }

  // Timeline build (stable hex bins)
  async function rebuildTimeline() {
    stopPlayback();
    const token = ++buildToken;

    // Rebuild stable registry from scratch on every timeline rebuild.
    // This prevents new hex objects from being created mid-playback (which would "pop" in).
    cellRegistry.clear();
    stableCells = [];

    // collect unique days
    const daySet = new Set();
    for (const p of filteredPoints) if (p.tDayMs != null) daySet.add(p.tDayMs);
    days = Array.from(daySet).sort((a,b)=>a-b);

    if (!days.length) {
      sliderEl.disabled = true;
      sliderEl.min = "0"; sliderEl.max = "0"; sliderEl.value = "0";
      timeLabelEl.textContent = "—";
      stepsLabelEl.textContent = "0 steps";
      shownPillEl.textContent = "0 shown";
      // вместо пустоты показываем базовую сетку UK
       try {
          const res = Number(h3resEl.value);
           // ВАЖНО: чтобы новые гексы не "появлялись", а росли 0→N,
// регистрируем все ячейки, которые могут возникнуть из данных.
seedRegistryFromPoints(filteredPoints, res);
          await ensureBaseGridFromPoints(res);
          cellsNow = stableCells;
        } catch (e) {
          console.warn("Base grid (bbox) failed:", e);
          cellsNow = [];
        }

      updateOverlay();
      setStat("Нет @timestamp в данных (или он не распарсился). Нужен properties['@timestamp'] из Overpass meta.");
      return;
    }

    // index days
    dayIndexByMs = new Map(days.map((ms, i) => [ms, i]));

    // prepare accumulative maps
    h3ByDay = Array.from({length: days.length}, () => new Map());

    const res = Number(h3resEl.value);

    // Pre-register all cells that can appear, so elevation transitions work as 0→N instead of popping in.
    seedRegistryFromPoints(filteredPoints, res);

    // base grid from points bbox (no external fetch)
    try {
      await ensureBaseGridFromPoints(res);
    } catch (e) {
      console.warn("Base grid (bbox) failed:", e);
    }

    if (token !== buildToken) return;

    // fill accumulative counts
    for (const p of filteredPoints) {
      if (p.tDayMs == null) continue;

      const idx = dayIndexByMs.get(p.tDayMs);
      if (idx == null) continue;

      const [lon, lat] = p.coordinates;
      const cell = h3.latLngToCell(lat, lon, res);

      // add this point to its day and all future days (accumulative)
      for (let j = idx; j < days.length; j++) {
        const m = h3ByDay[j];
        m.set(cell, (m.get(cell) || 0) + 1);
      }
    }

    sliderEl.disabled = false;
    sliderEl.min = "0";
    sliderEl.max = String(days.length - 1);
    sliderEl.value = "0";
    stepsLabelEl.textContent = `${days.length} steps`;
    const startEl = document.getElementById("startLabel");
    const endEl = document.getElementById("endLabel");
    if (startEl) startEl.textContent = fmtDay(days[0]);
    if (endEl) endEl.textContent = fmtDay(days[days.length-1]);

    applyTimeline(0);

    setStat(`Points: ${allPoints.length}. After search: ${filteredPoints.length}. Timeline steps: ${days.length} (by day). H3 res: ${res}.`);
    console.log("days:", days.length, "cellsNow sample:", cellsNow.slice(0,3));

  }

  function applyTimeline(idx) {
    const t = days[idx];
    timeLabelEl.textContent = fmtDay(t);

    const m = h3ByDay[idx] || new Map();

    // Update stable objects (reuse across frames) so transitions are smooth.
    // First set all known cells to 0, then apply counts for this frame.
    for (const obj of stableCells) {
      obj.prevCount = obj.count || 0;
      obj.count = 0;
    }
    for (const [cell, count] of m.entries()) {
      const obj = cellRegistry.get(cell);
      if (!obj) continue; // never create new cells during playback
      obj.count = count;
    }

    const now = performance.now();
    let latestGlow = 0;
    for (const obj of stableCells) {
      if (obj.count > (obj.prevCount || 0)) {
        obj.glowStart = now + GLOW_DELAY_MS;
        obj.glowUntil = obj.glowStart + GLOW_DURATION_MS;
      }
      if (obj.glowUntil && obj.glowUntil > latestGlow) {
        latestGlow = obj.glowUntil;
      }
    }
    glowActiveUntil = Math.max(glowActiveUntil, latestGlow);
    startGlowTicker();

    // IMPORTANT: deck.gl transitions are triggered when the `data` prop changes.
    // We keep stable object identities (so values can tween), but pass a new
    // array reference each frame so attributes re-evaluate and animate.
    cellsNow = stableCells.slice();
    frameTick++;


    const total = Array.from(m.values()).reduce((s, v) => s + v, 0);
    shownPillEl.textContent = `${total} shown`;

    updateOverlay();
  }

  function startGlowTicker() {
    if (glowTicker) return;
    const tick = () => {
      const now = performance.now();
      if (now - lastGlowUpdate >= GLOW_UPDATE_INTERVAL_MS) {
        frameTick++;
        updateOverlay();
        lastGlowUpdate = now;
      }
      if (now < glowActiveUntil) {
        glowTicker = requestAnimationFrame(tick);
      } else {
        glowTicker = null;
      }
    };
    glowTicker = requestAnimationFrame(tick);
  }

  // Playback
  function stopPlayback() {
    playing = false;
    playBtn.textContent = "▶";
    if (timer) { clearInterval(timer); timer = null; }
  }
  function startPlayback() {
    if (!days.length) return;
    playing = true;
    playBtn.textContent = "❚❚";
    timer = setInterval(() => {
      const v = Number(sliderEl.value);
      if (v >= days.length - 1) { stopPlayback(); return; }
      sliderEl.value = String(v + 1);
      applyTimeline(Number(sliderEl.value));
    }, PLAY_INTERVAL_MS);
  }

  // UI wiring
  sliderEl.addEventListener("input", () => { stopPlayback(); applyTimeline(Number(sliderEl.value)); });
  playBtn.addEventListener("click", () => { if (!days.length) return; playing ? stopPlayback() : startPlayback(); });
  document.getElementById("rewind").addEventListener("click", () => { stopPlayback(); sliderEl.value="0"; applyTimeline(0); });

  elevEl.addEventListener("input", () => { setVals(); updateOverlay(); });
  logToggleEl.addEventListener("change", () => { updateOverlay(); });
  paletteEl.addEventListener("change", () => { setVals(); updateOverlay(); });

  h3resEl.addEventListener("change", () => {
    setVals();
    // rebuild bins with new resolution so they remain stable
    rebuildTimeline();
  });

  // Search removed

  
  document.getElementById("clear").addEventListener("click", () => {
    stopPlayback();
    allPoints=[]; filteredPoints=[]; days=[]; dayIndexByMs=new Map(); h3ByDay=[]; cellsNow=[];
    fileEl.value="";
    dataLatRange = { min: -90, max: 90 };
    sliderEl.disabled=true; sliderEl.min="0"; sliderEl.max="0"; sliderEl.value="0";
    timeLabelEl.textContent="—"; stepsLabelEl.textContent="0 steps"; shownPillEl.textContent="0 shown";
    setStat("Cleared.");
    updateOverlay();
  });

  document.getElementById("fit").addEventListener("click", () => {
    const b = boundsFromPoints(filteredPoints);
    if (!b) return;
    const [minLon,minLat,maxLon,maxLat] = b;
    map.fitBounds([[minLon, minLat], [maxLon, maxLat]], {padding: 60, duration: 600});
  });

  function loadGeoJSONData(geo, sourceLabel) {
    const raw = extractPointsFromGeoJSON(geo);

    if (!raw.length) {
      setStat("Файл загрузился, но точек нет. Проверь, что GeoJSON содержит Point-геометрии.");
      return;
    }

    allPoints = raw.map(p => {
      const props = p.properties || {};
      const ts = getProp(props, ["@timestamp", "timestamp"]);
      const ms = ts ? parseTimestampToMs(ts) : null;
      return {
        coordinates: p.coordinates,
        properties: props,
        tDayMs: (ms != null) ? toDayMs(ms) : null
      };
    }).filter(p => Array.isArray(p.coordinates) && typeof p.coordinates[0] === "number" && typeof p.coordinates[1] === "number");

    filteredPoints = [...allPoints];
    rebuildTimeline();

    const b = boundsFromPoints(filteredPoints);
    if (b) {
      const [minLon, minLat, maxLon, maxLat] = b;
      dataLatRange = { min: minLat, max: maxLat };
      map.fitBounds([[minLon, minLat], [maxLon, maxLat]], {padding: 60, duration: 600});
    } else {
      dataLatRange = { min: -90, max: 90 };
    }

    setVals();
    updateOverlay();
    if (sourceLabel) {
      setStat(`Loaded: ${sourceLabel}. Points: ${allPoints.length}.`);
    }
  }

  // Load file from local computer
  fileEl.addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if (!f) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const geo = JSON.parse(reader.result);
        loadGeoJSONData(geo, f.name);
      } catch (err) {
        console.error(err);
        alert("Не удалось распарсить JSON/GeoJSON.");
      }
    };
    reader.readAsText(f);
  });

  // Load file from server
  document.getElementById("loadServer").addEventListener("click", async () => {
    const fileName = serverFileEl?.value;
    if (!fileName) return;
    try {
      const res = await fetch(fileName, {cache: "no-store"});
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const geo = await res.json();
      loadGeoJSONData(geo, `server/${fileName}`);
    } catch (err) {
      console.error(err);
      alert("Не удалось загрузить файл с сервера.");
    }
  });

    map.on("load", async () => {
      setStat("Выбери uk-datacenters.geojson. Совет: log выключен = строго линейные высоты.");

      // Всегда строим базовую сетку и показываем её с нулевыми значениями
      try {
        const res = Number(h3resEl.value);
        await ensureBaseGrid(res);
        cellsNow = stableCells; // все клетки UK (count=0)
        updateOverlay();
      } catch (e) {
        console.warn("Base grid init failed:", e);
        updateOverlay();
      }
    });
  })();

</script>
</body>
</html>
